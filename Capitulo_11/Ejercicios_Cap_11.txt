11.3 Explore qué sucede cuando el tamaño de la tabla hash es una potencia de 2 en lugar de un número primo. Vuelva a escribir el método HashTable.__growTable() para que duplique el tamaño de la tabla sin encontrar el siguiente número primo mayor que ese. Utilice las mismas condiciones que en el Proyecto 11.1, excepto que utilice un tamaño inicial de 128 para las tablas hash. Las 200 claves que se insertan obligarán a la tabla a crecer al menos una vez, y debería seguir siendo una potencia de 2. Usar un tamaño de tabla que no sea un número primo aumenta las posibilidades de colisiones, hasta el punto de que es probable que se ejecute. en la excepción generada por el método insert() cuando la secuencia de sonda se queda sin celdas para probar (consulte el Listado 11-5). La excepción ocurrirá solo para algunas distribuciones de claves, por lo que es posible que deba inicializar el generador de números aleatorios con diferentes valores para causar la excepción. Asegúrese de detectar la excepción y registrar el problema para la secuencia de sonda y el factor de carga particulares. El mismo conjunto de claves puede funcionar con una secuencia de sonda, pero no con otras. Como en el Proyecto 11.1, muestre el número de claves desplazadas para las nueve condiciones diferentes: tres esquemas de sonda multiplicados por tres factores de carga. Si las 200 claves no se pueden insertar para una condición particular, muéstrelo también.

11.4 El cálculo del tamaño del paso de hash doble en el Listado 11-10 utiliza la función simplehash(). Reemplace esa función con una función hash multiplicativa que es una variación del método de Horner descrito en la sección "Cadenas Hashing", excepto que está diseñada para funcionar con claves hash enteras. Las claves de números enteros se pueden tratar como una secuencia de bytes. Puedes obtener el byte más bajo de un número entero grande N usando un bit máscara en Python, N y 0xFF. El bucle itera sobre los bytes y calcula un hash que comienza en 0. En cada iteración, el hash actual se multiplica por un número primo y el byte bajo más otro número primo se suman para obtener el siguiente valor del hash. Multiplicar por un número primo y agregar otro número primo ayuda a distribuir la influencia de cada bit de la clave en el valor hash. Genere una tabla como la Tabla 11-2 que muestre la inserción de 20 claves enteras seleccionadas aleatoriamente del rango [0, 99999]. Muestre la dirección hash multiplicativa junto con el módulo con el primo pequeño para derivar el tamaño del paso. Debe escribir algo de código para producir la secuencia de sonda y echar un vistazo a los valores almacenados antes de insertar el elemento en la tabla hash para mostrar la última columna de la tabla.


---------------------------------------------------------------


11.3 Explore what happens when the hash table size is a power of 2
instead of a prime number. Rewrite the HashTable.__growTable()
method so that it doubles the size of the table without finding the next
prime number larger than that. Use the same conditions as in Project
11.1, except use a starting size of 128 for the hash tables. The 200
keys that are inserted will force the table to grow at least once, and it
should remain a power of 2.
Using a table size that is not a prime number increases the chances of
collisions, so much so that you are likely to run into the exception
raised by the insert() method when the probe sequence runs out of
cells to try (see Listing 11-5). The exception will happen for only
some distributions of keys, so you may need to seed the random
number generator with different values to cause the exception. Make
sure you catch the exception and record the problem for the particular
probe sequence and load factor. The same set of keys may work with
one probe sequence, but not in others.
As in Project 11.1, show the number of displaced keys for the nine
different conditions: three probe schemes times three load factors. If
the 200 keys cannot be inserted for a particular condition, show that
too.

11.4 The double hashing step size calculation in Listing 11-10 uses
the simplehash() function. Replace that function with a multiplicative
hashing function that is a variation on Horner’s method described in
the “Hashing Strings” section, except that it’s designed to work with
integer hash keys. The integer keys can be treated as a sequence of
bytes. You can get the lowest byte from a big integer N by using a bit
mask in Python, N & 0xFF. The loop iterates over the bytes and
computes a hash that starts at 0. On each iteration, the current hash is
multiplied by a prime, and the low byte plus another prime are added
to get the next value of the hash. Multiplying by a prime and adding
another prime help spread the influence of each bit of the key across
the hashed value.
Produce a table like Table 11-2 showing the insertion of 20 integer
keys randomly selected from the range [0, 99999]. Show the
multiplicative hashed address along with the modulo with the small
prime to derive the step size. You need to write some code to produce
the probe sequence and peek at the stored values before inserting the
item in the hash table in order to show the last column of the table.