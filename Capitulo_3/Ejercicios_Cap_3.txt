3.1 En el método bubbleSort() (Listado 3-1) y la herramienta Visualización
el índice interior siempre va de izquierda a derecha, encontrando el
elemento más grande y llevándolo hacia la derecha. Modifica el método bubbleSort()
para que sea bidireccional. Esto significa que el índice interno primero
primero llevará el elemento mayor de izquierda a derecha como antes, pero cuando llegue al
último, se invertirá y llevará el elemento más pequeño de derecha a izquierda. En
necesita dos índices externos, uno a la derecha (el antiguo último) y otro a la izquierda.
la izquierda.

3.2 Añade un método llamado median() a la clase Array en el módulo
SortArray.py (Listado 3-4). Este método debe devolver el valor
la mediana del array. (Recuerda que en un grupo de números, la mitad son
más grandes que la mediana y la otra mitad son más pequeños). Hazlo de la manera fácil.

3.3 Añade un método llamado deduplicate() a la clase Array en el módulo
módulo SortArray.py (Listado 3-4) que elimine los duplicados de una
previamente ordenado sin alterar el orden. Puede utilizar cualquiera
de los métodos de ordenación en su programa de prueba para ordenar los datos. Puede
imaginar esquemas en los que todos los elementos desde el lugar donde se
duplicado hasta el final de la matriz se desplazarían
hacia abajo un espacio cada vez que se descubriera un duplicado, pero esto
tiempo O(N2), al menos cuando hay muchos duplicados.
duplicados. En su algoritmo, asegúrese de que ningún elemento se mueve más de
una vez, sin importar cuántos duplicados haya. Esto le dará un
algoritmo con tiempo O(N).

3.4 Otra ordenación sencilla es la ordenación par-impar. La idea es hacer
dos pasadas por el array. En la primera, se miran todos
los pares de elementos, a[j] y a[j + 1], donde j es impar (j = 1, 3, 5, ...). Si
sus valores clave están desordenados, los intercambias. En la segunda pasada,
haces lo mismo con todos los valores pares (j = 0, 2, 4, ...). Estas dos
repetidamente hasta que el array esté ordenado. Añade un método oddEvenSort()
a la clase Array en el módulo SortArray.py (Listado 3-4).
Realiza el bucle exterior hasta que no se produzcan intercambios para ver cuántas pasadas
una pasada incluye el intercambio de pares e impares.
Asegúrese de que funciona para diferentes cantidades de datos y en buenas y malas
ordenaciones iniciales buenas y malas. Después de comprobar cuántas pasadas son necesarias
no se produzcan más intercambios, determine el número máximo de pasadas del bucle
en función de la longitud de la matriz de entrada.
La ordenación par-impar es realmente útil en un entorno de multiprocesamiento
multiprocesamiento, donde un procesador separado puede operar en cada par impar
simultáneamente y luego en cada par. Como los pares impares son
independientes entre sí, cada par puede ser comprobado-y intercambiado
en caso necesario. Esto hace que la
muy rápida.

3.5 Modifica el método insertionSort() en SortArray.py (Listado 3-
4) para que cuente el número de copias y el número de comparaciones
comparaciones de elementos durante una ordenación y muestre los totales. Es necesario
condición de bucle en el bucle while interno y contar cuidadosamente las comparaciones de elementos.
cuidadosamente las comparaciones de elementos. Utiliza este programa para medir el número de
copias y comparaciones para diferentes cantidades de datos
inversamente ordenados. ¿Los resultados verifican la eficiencia O(N2)? Haga lo mismo para datos
(sólo unos pocos elementos fuera de lugar). ¿Qué puede deducir
sobre la eficiencia de este algoritmo para datos casi ordenados?

3.6 He aquí una forma interesante de eliminar elementos con claves duplicadas
de una matriz. La ordenación por inserción utiliza un algoritmo de bucle dentro de bucle
que compara cada elemento del array con los elementos parcialmente ordenados
parcialmente ordenados. Una forma de eliminar elementos con claves duplicadas sería
modificar el algoritmo de la clase Array en el módulo SortArray.py
(Listado 3-4) para que elimine los duplicados a medida que ordena. Esta es una
método: Cuando se encuentra una clave duplicada, en lugar de copiar el
duplicado en la celda del array en su posición de ordenación, cambie la clave
para que el elemento marcado sea un valor especial que se trate como inferior a
cualquier otra clave posible. Con ese valor de clave bajo, se
automáticamente al principio de la matriz. Llevando la cuenta de
cuántos duplicados se encuentran, se conoce el final de los duplicados y el
principio de los elementos restantes del array. Cuando el bucle
bucle exterior, el algoritmo tendría que hacer una pasada más para desplazar
las claves únicas en las celdas ocupadas por los duplicados. Escribe un
método insertionSortAndDedupe() que realice esta operación.
Asegúrate de probar que funciona con todos los tipos de datos de entrada.
datos.